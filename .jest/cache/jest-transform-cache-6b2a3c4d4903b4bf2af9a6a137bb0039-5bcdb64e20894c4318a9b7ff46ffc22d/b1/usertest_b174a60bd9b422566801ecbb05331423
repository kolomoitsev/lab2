2bfafed78f0ddb473abe52f587f1c22a
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const jest_mock_extended_1 = require("jest-mock-extended");
const user_controller_1 = require("../controllers/user.controller");
const config_1 = require("../config");
const mongoose = require('mongoose');
jest.useFakeTimers();
describe('Testing user controller', () => {
    beforeEach(() => {
        jest.setTimeout(10000);
    });
    test('testing finding user', () => __awaiter(void 0, void 0, void 0, function* () {
        const MONGODB_LINK = config_1.config.MONGOOSE_LINK;
        mongoose.connect(MONGODB_LINK, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            useCreateIndex: true
        })
            .catch((err) => console.log(err));
        mongoose.connection.once('open', () => {
            console.log(`MongoDb connection established successfully`);
        })
            .on('error', () => {
            console.log('connection error');
        });
        const userController = new user_controller_1.UserController();
        const user = (0, jest_mock_extended_1.mock)();
        const pavlo = yield userController.findUser('6186fe32c5880ccea55d0473');
        expect(pavlo).toBeInstanceOf(user);
    }));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2FwcGxlL0Rlc2t0b3AvcGVyc29uYWwvdW5pL3Rlc3RpbmcvbGFiMi9zcmMvdGVzdHMvdXNlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0EsMkRBQTBDO0FBQzFDLG9FQUFnRTtBQUNoRSxzQ0FBbUM7QUFFbkMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3JDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUVyQixRQUFRLENBQUMseUJBQXlCLEVBQUUsR0FBRyxFQUFFO0lBQ3JDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDWixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsSUFBSSxDQUFDLHNCQUFzQixFQUFFLEdBQVMsRUFBRTtRQUNwQyxNQUFNLFlBQVksR0FBRyxlQUFNLENBQUMsYUFBYSxDQUFDO1FBQzFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQzNCLGVBQWUsRUFBRSxJQUFJO1lBQ3JCLGtCQUFrQixFQUFFLElBQUk7WUFDeEIsY0FBYyxFQUFFLElBQUk7U0FDdkIsQ0FBQzthQUNHLEtBQUssQ0FBQyxDQUFDLEdBQVEsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRTNDLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7WUFDbEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1FBQy9ELENBQUMsQ0FBQzthQUNHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQ2QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3BDLENBQUMsQ0FBQyxDQUFDO1FBQ1AsTUFBTSxjQUFjLEdBQUcsSUFBSSxnQ0FBYyxFQUFFLENBQUM7UUFDNUMsTUFBTSxJQUFJLEdBQUcsSUFBQSx5QkFBSSxHQUFTLENBQUM7UUFDM0IsTUFBTSxLQUFLLEdBQUcsTUFBTSxjQUFjLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFDeEUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUEsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2FwcGxlL0Rlc2t0b3AvcGVyc29uYWwvdW5pL3Rlc3RpbmcvbGFiMi9zcmMvdGVzdHMvdXNlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElVc2VyIH0gZnJvbSAnLi4vdHlwZXMvdXNlci50eXBlcyc7XG5pbXBvcnQgeyBtb2NrIH0gZnJvbSAnamVzdC1tb2NrLWV4dGVuZGVkJztcbmltcG9ydCB7IFVzZXJDb250cm9sbGVyIH0gZnJvbSAnLi4vY29udHJvbGxlcnMvdXNlci5jb250cm9sbGVyJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbmplc3QudXNlRmFrZVRpbWVycygpO1xuXG5kZXNjcmliZSgnVGVzdGluZyB1c2VyIGNvbnRyb2xsZXInLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3Quc2V0VGltZW91dCgxMDAwMCk7XG4gICAgfSk7XG4gICAgdGVzdCgndGVzdGluZyBmaW5kaW5nIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IE1PTkdPREJfTElOSyA9IGNvbmZpZy5NT05HT09TRV9MSU5LO1xuICAgICAgICBtb25nb29zZS5jb25uZWN0KE1PTkdPREJfTElOSywge1xuICAgICAgICAgICAgdXNlTmV3VXJsUGFyc2VyOiB0cnVlLFxuICAgICAgICAgICAgdXNlVW5pZmllZFRvcG9sb2d5OiB0cnVlLFxuICAgICAgICAgICAgdXNlQ3JlYXRlSW5kZXg6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyOiBhbnkpID0+IGNvbnNvbGUubG9nKGVycikpO1xuXG4gICAgICAgIG1vbmdvb3NlLmNvbm5lY3Rpb24ub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb25nb0RiIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdXNlckNvbnRyb2xsZXIgPSBuZXcgVXNlckNvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgdXNlciA9IG1vY2s8SVVzZXI+KCk7XG4gICAgICAgIGNvbnN0IHBhdmxvID0gYXdhaXQgdXNlckNvbnRyb2xsZXIuZmluZFVzZXIoJzYxODZmZTMyYzU4ODBjY2VhNTVkMDQ3MycpO1xuICAgICAgICBleHBlY3QocGF2bG8pLnRvQmVJbnN0YW5jZU9mKHVzZXIpO1xuICAgIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=